## Amazon DynamoDB
- **Amazon DynamoDB** được thiết kế dựa trên triết lý ưu tiên tuyệt đối cho hiệu năng và tính liên tục của dịch vụ, đặc biệt là trong các kịch bản quy mô lớn của Amazon. Dưới đây là các đặc điểm cốt lõi giúp nó vận hành hiệu quả:

* **Giao diện đơn giản (Simple Interface):** Hoạt động như một kho lưu trữ **Key-Value**, cho phép truy xuất dữ liệu cực nhanh thông qua các khóa định danh mà không cần các cấu trúc bảng phức tạp.
* **Đánh đổi tính Nhất quán để lấy tính Sẵn sàng:** DynamoDB sẵn sàng hy sinh tính nhất quán nghiêm ngặt (strong consistency) để đảm bảo hệ thống luôn hoạt động. Đây là minh chứng điển hình cho việc lựa chọn **AP** (Availability & Partition Tolerance) trong định lý CAP.
* **Kho lưu trữ "Luôn luôn cho phép ghi" (Always writeable):** Một trong những mục tiêu quan trọng nhất là không có bất kỳ yêu cầu cập nhật nào bị từ chối do lỗi hệ thống hoặc các thao tác ghi đồng thời (**concurrent writes**). Điều này đảm bảo trải nghiệm người dùng (như thêm hàng vào giỏ) không bao giờ bị gián đoạn.
* **Giải quyết xung đột khi Đọc (Conflict resolution during read):** Thay vì làm chậm quá trình Ghi bằng cách bắt các node phải thống nhất dữ liệu ngay lập tức (conflict resolution during write), DynamoDB cho phép ghi tự do. Nếu có sự sai lệch dữ liệu giữa các bản sao, việc đối soát và giải quyết xung đột sẽ được thực hiện khi người dùng thực hiện lệnh **Đọc**.
* **Môi trường tin cậy (Trusted domain):** Hệ thống được vận hành trong một miền quản trị duy nhất, nơi tất cả các node được giả định là an toàn và tin tưởng lẫn nhau, giúp giảm thiểu các bước xác thực phức tạp giữa các thành phần nội bộ.

## Design consideration
- Khi thiết kế DynamoDB, Amazon đã tập trung vào 4 nguyên tắc cốt lõi để đảm bảo hệ thống có thể vận hành ổn định ở quy mô toàn cầu mà không gặp phải các điểm nghẽn truyền thống:

* **Khả năng mở rộng gia tăng (Incremental scalability):** Hệ thống cho phép thêm các node mới vào cụm (cluster) một cách linh hoạt mà không làm gián đoạn dịch vụ. Khả năng này giúp hệ thống thích ứng tức thì với sự tăng trưởng dữ liệu và lưu lượng truy cập theo thời gian.
* **Tính đối xứng (Symmetry):** Trong Dynamo, mọi node đều có vai trò và trách nhiệm hoàn toàn giống nhau. Không có sự phân biệt giữa node "chủ" hay "tớ". Điều này giúp đơn giản hóa việc quản trị và mở rộng, vì bạn chỉ cần thêm các node tương tự nhau vào hệ thống.
* **Tính phi tập trung (Decentralization):** Rút kinh nghiệm từ quá khứ khi các hệ thống điều khiển trung tâm thường là nguyên nhân gây ra các vụ sập nguồn hàng loạt (outages), Dynamo ưu tiên thiết kế phi tập trung. Các quyết định và việc quản lý dữ liệu được phân tán đều, giúp hệ thống có khả năng chịu lỗi cực cao.
* **Tính hỗn hợp (Heterogeneity):** Đây là yếu tố then chốt cho phép hệ thống làm việc với các máy chủ có cấu hình khác nhau. Bạn có thể thêm các máy mới với dung lượng lớn hơn, CPU mạnh hơn vào cụm hiện tại mà không buộc phải nâng cấp đồng loạt tất cả các máy chủ cũ, giúp tối ưu hóa chi phí đầu tư phần cứng.


## Partition algorithm
- Để giải quyết bài toán phân tán dữ liệu một cách hiệu quả và đối xứng, DynamoDB sử dụng thuật toán **Consistent Hashing** kết hợp với kiến trúc **Zero-hop DHT**.

### Thuật toán Consistent Hashing

Trong Consistent Hashing, phạm vi đầu ra của một hàm băm (hash function) được coi là một không gian vòng tròn cố định, hay còn gọi là một **"Ring"** (vòng băm).

* Mỗi máy chủ (node) được gán một vị trí trên vòng tròn này (có thể dựa vào ID hoặc IP của nó vv)
* Khi một dữ liệu (key) được đưa vào, nó cũng được băm **để tìm một vị trí trên vòng**.
* Dữ liệu đó sẽ được lưu trữ tại **node đầu tiên xuất hiện khi ta đi theo chiều kim đồng hồ** từ vị trí của key.

### Zero-hop DHT (Distributed Hash Table)

DynamoDB được mô tả là một **Zero-hop DHT**. Điều này có nghĩa là bất kỳ node nào trong hệ thống cũng có khả năng điều hướng yêu cầu đến đúng node chứa dữ liệu chỉ trong "0 bước" chuyển tiếp (hop). Khác với các hệ thống DHT truyền thống (như Chord) yêu cầu truy vấn qua nhiều node trung gian ( hops), trong DynamoDB, client hoặc node tiếp nhận có thể gửi thẳng yêu cầu đến node đích.

### Lời giải cho "Grand Challenge": Làm sao để mọi node luôn cập nhật được trạng thái của Ring?

Thách thức lớn nhất ở đây là: Nếu không có máy chủ trung tâm, làm thế nào để hàng nghìn máy chủ luôn biết rõ node nào vừa gia nhập, node nào vừa sập để cập nhật "bản đồ" cái Ring?

Câu trả lời chính là **Gossip Protocol (Giao thức tin đồn)**: (Membership and failure detection)

1. **Cơ chế lan truyền:** Cứ mỗi giây, mỗi node sẽ chọn ngẫu nhiên một vài node khác trong hệ thống để trao đổi thông tin về trạng thái của chính nó và các node khác mà nó biết.
2. **Sự hội tụ:** Giống như một tin đồn trong đám đông, thông tin về việc một máy chủ mới gia nhập hoặc một node bị hỏng sẽ lan truyền cực nhanh. Chỉ trong một thời gian rất ngắn, toàn bộ các node trong hệ thống sẽ đạt được sự đồng thuận về cấu trúc hiện tại của Ring.
3. **Tính bền bỉ:** Vì không dựa vào một node quản lý duy nhất, ngay cả khi nhiều máy chủ bị mất kết nối cùng lúc, "tin đồn" vẫn sẽ tìm được đường đi vòng qua các node còn sống để cập nhật trạng thái hệ thống.

---
## Virtual Nodes

Kỹ thuật **Virtual Nodes** (Node ảo) là một cải tiến quan trọng cho thuật toán Consistent Hashing truyền thống trong DynamoDB, giúp giải quyết triệt để các vấn đề về phân phối tải và sự không đồng nhất của phần cứng. (Ví dụ theo chiều kim đồng hồ, node A yếu đặt gần node B, node B lại xa node C yếu thì lúc này tải có thể phân bố nhiều vào node A hoặc node C)

### Cơ chế hoạt động của Virtual Nodes

Thay vì một máy chủ vật lý chỉ đại diện cho một điểm duy nhất trên vòng băm (Ring), mỗi máy chủ vật lý hiện nay sẽ chịu trách nhiệm cho **nhiều node ảo** khác nhau. Các node ảo này được phân tán ngẫu nhiên tại nhiều vị trí khác nhau trên khắp vòng tròn.

* **Tương thích với tính hỗn hợp (Heterogeneity):** Số lượng node ảo mà một máy chủ đảm nhiệm sẽ tỷ lệ thuận với năng lực xử lý của nó. Những máy chủ mạnh hơn (nhiều RAM, CPU hơn) sẽ được gán nhiều node ảo hơn, từ đó đảm nhận nhiều phần dữ liệu hơn trên Ring.
* **Phân tán node ảo:** Việc rải rác các node ảo khắp vòng tròn giúp dữ liệu được chia nhỏ và phân bổ đều hơn, tránh tình trạng "điểm nóng" (hotspots) tập trung vào một máy chủ duy nhất.


### Những ưu điểm vượt trội

Việc sử dụng Virtual Nodes mang lại lợi ích to lớn trong việc quản lý tải trọng khi cấu trúc hệ thống thay đổi:

1. **Phân tán tải đều khi có sự cố:** Nếu một máy chủ vật lý bị hỏng, các node ảo của nó biến mất. Tuy nhiên, vì các node ảo này nằm rải rác cạnh nhiều node ảo của các máy chủ khác nhau, nên tải trọng mà nó từng đảm nhận sẽ được **chia đều** cho toàn bộ các máy còn lại trong hệ thống, thay vì dồn hết lên một máy lân cận duy nhất.
2. **Tái cân bằng tải mượt mà:** Khi một máy chủ mới được thêm vào hoặc một máy chủ cũ quay trở lại hoạt động, nó sẽ "nhận lại" một lượng tải tương đương từ **tất cả** các máy chủ hiện có thông qua các vị trí node ảo mới. Quá trình này diễn ra nhẹ nhàng và không gây áp lực đột ngột lên bất kỳ máy chủ nào.
3. **Tối ưu hóa hạ tầng vật lý:** Khả năng điều chỉnh số lượng node ảo dựa trên cấu hình máy chủ cho phép hệ thống tận dụng tối đa sức mạnh của các phần cứng mới nhất mà không gây lãng phí, đảm bảo mọi tài nguyên trong hệ thống đều được khai thác hiệu quả nhất.

---
## Replication, Quorum

Để đảm bảo tính nhất quán của dữ liệu trong một hệ thống phân tán mà vẫn duy trì được hiệu năng, DynamoDB sử dụng cơ chế **Quorum** (tạm dịch là "số đông tối thiểu") và các kỹ thuật xử lý lỗi tạm thời như **Sloppy Quorum** hay **Hinted Handoff**.

### 1. Cơ chế Quorum ()

Đây là mô hình giúp hệ thống kiểm soát sự cân bằng giữa tính nhất quán và độ trễ (latency). Các tham số chính bao gồm:

* **:** Tổng số bản sao (replicas) của mỗi cặp key/value.
* **:** Số node tối thiểu phải phản hồi thành công để một thao tác **Đọc** được coi là hoàn tất.
* **:** Số node tối thiểu phải phản hồi thành công để một thao tác **Ghi** được coi là hoàn tất.

**Quy tắc vàng:** Để đảm bảo tính nhất quán (người đọc luôn thấy dữ liệu mới nhất), ta phải thiết lập ****. Điều này đảm bảo rằng tập hợp các node tham gia vào quá trình đọc và tập hợp các node tham gia vào quá trình ghi luôn có ít nhất một node chung (overlap).

> **Lưu ý về hiệu năng:** Độ trễ của hệ thống sẽ phụ thuộc vào node **chậm nhất** trong số  hoặc  node. Vì vậy, người ta thường cấu hình  và  nhỏ hơn  (ví dụ: ) để hệ thống vẫn hoạt động tốt ngay cả khi có một node bị chậm hoặc lỗi.

### 2. Xử lý lỗi tạm thời: Sloppy Quorum và Hinted Handoff

Trong các hệ thống lớn, việc một node bị mất kết nối tạm thời là chuyện xảy ra hàng ngày. Thay vì từ chối lệnh ghi (vi phạm nguyên tắc "always writeable"), DynamoDB sử dụng:

* **Sloppy Quorum (Quorum "lỏng lẻo"):** Nếu một node trong danh sách  node ưu tiên bị hỏng, hệ thống sẽ tạm thời ghi dữ liệu vào một node khác nằm ngoài danh sách đó (nhưng vẫn nằm trên vòng Ring).
* **Hinted Handoff (Chuyển giao gợi ý):** * **Ví dụ:** Giả sử  (dữ liệu đáng lẽ nằm ở node A, B, C). Khi node B bị sập, hệ thống sẽ gửi bản sao đó sang node E.
* Bản sao tại node E sẽ đi kèm một "gợi ý" (hint) rằng: *"Dữ liệu này thực chất thuộc về B"*.
* Node E lưu giữ dữ liệu này trong một hàng đợi riêng. Ngay khi phát hiện node B đã khôi phục (thông qua Gossip Protocol), node E sẽ lập tức chuyển trả dữ liệu đó cho B.

---
## Replica synchronization (Recovering from permanent failures)

Trong cơ chế **Replica Synchronization** (đồng bộ hóa bản sao), đặc biệt là quy trình **Anti-entropy** (chống lại sự hỗn loạn dữ liệu), **Merkle Tree** đóng vai trò là "người gác cổng" giúp phát hiện sự sai lệch dữ liệu một cách nhanh chóng và ít tốn kém nhất, **giúp đồng bộ dữ liệu.**

### Cấu trúc và Nguyên lý

Merkle Tree là một cấu trúc cây băm phân cấp:

* **Nút lá (Leaves):** Chứa giá trị băm (hash) của từng cặp key/value riêng lẻ.
* **Nút cha (Parent nodes):** Là giá trị băm được tạo ra từ việc kết hợp các mã băm của các nút con trực tiếp. Quá trình này tiếp diễn cho đến khi đạt tới **Root Hash** (mã băm gốc) đại diện cho toàn bộ tập dữ liệu.

### Ưu điểm vượt trội trong đồng bộ hóa

Việc sử dụng Merkle Tree mang lại những lợi ích mang tính sống còn cho các hệ thống phân tán lớn:

1. **Kiểm tra độc lập từng nhánh:** Các node không cần phải tải xuống toàn bộ cây dữ liệu để so sánh. Chúng chỉ cần so sánh mã băm ở các nút cha. Nếu mã băm của một nút cha giống nhau, hệ thống mặc định toàn bộ các nhánh con bên dưới nó đã khớp và không cần kiểm tra thêm.
2. **Giảm thiểu dữ liệu truyền tải:** Thay vì gửi hàng Terabyte dữ liệu qua mạng để đối soát, các máy chủ chỉ trao đổi các mã băm nhỏ gọn. Chỉ khi phát hiện ra sự khác biệt ở một nhánh cụ thể, hệ thống mới đi sâu vào nhánh đó để tìm ra các key bị sai lệch và truyền tải đúng phần dữ liệu cần cập nhật.
3. **Xử lý bất đồng nhất nhanh chóng:** Cơ chế này giúp quá trình đồng bộ hóa giữa các bản sao diễn ra liên tục mà không gây nghẽn băng thông, đảm bảo tính nhất quán cuối cùng (Eventual Consistency) của hệ thống NoSQL.


--- 
## Data versioning & Vector Clocks

Trong một hệ thống "luôn luôn cho phép ghi" như DynamoDB, việc xử lý nhiều phiên bản của cùng một dữ liệu là điều tất yếu. Dưới đây là cách hệ thống quản lý sự phức tạp này thông qua **Data Versioning** và **Vector Clocks**.

### Thách thức của việc Ghi dữ liệu phân tán

* **Độ trễ:** Một lệnh `put()` có thể phản hồi thành công ngay khi chỉ một vài node ghi nhận, trước khi toàn bộ các bản sao (replicas) được cập nhật.
* **Đa phiên bản:** Một lệnh `get()` có thể trả về nhiều phiên bản khác nhau của cùng một đối tượng nếu quá trình đồng bộ chưa hoàn tất hoặc có các thao tác ghi đồng thời xảy ra trên các node khác nhau.
* **Vấn đề cốt lõi:** Làm thế nào để biết phiên bản nào là "con" (mới hơn) của phiên bản nào, và khi nào thì hai phiên bản bị xung đột (không có quan hệ cha con) cần phải được hợp nhất (reconciled)?

---

### Giải pháp: Vector Clocks

**Vector clock** là một danh sách các cặp **(node, counter)** dùng để ghi lại lịch sử quan hệ nhân quả (causality) giữa các phiên bản. Mỗi phiên bản của một đối tượng sẽ được gắn chặt với một Vector clock riêng.

#### Cách xác định quan hệ giữa hai phiên bản:

Giả sử chúng ta có hai phiên bản của cùng một đối tượng với hai Vector clock tương ứng:

1. **Quan hệ Cha - Con (Ancestor):** Nếu tất cả các bộ đếm (counters) trong Vector clock của đối tượng thứ nhất đều **nhỏ hơn hoặc bằng** các bộ đếm tương ứng trong Vector clock của đối tượng thứ hai, thì đối tượng thứ nhất là tổ tiên của đối tượng thứ hai.
* **Hành động:** Hệ thống có thể an tâm xóa bỏ (forget) phiên bản cũ vì thông tin của nó đã được bao hàm trong phiên bản mới.


2. **Xung đột (Conflict/Concurrent):** Nếu có ít nhất một node mà bộ đếm của vật A lớn hơn vật B, đồng thời một node khác mà bộ đếm của vật B lại lớn hơn vật A, thì hai phiên bản này được coi là "song song" và xung đột.
* **Hành động:** Hệ thống sẽ giữ lại cả hai và yêu cầu ứng dụng (hoặc người dùng) tự giải quyết xung đột khi đọc dữ liệu.



---

### Ví dụ minh họa quá trình cập nhật:

1. **Node A** ghi dữ liệu: Clock là `[(A, 1)]`.
2. **Node A** ghi tiếp: Clock tăng lên `[(A, 2)]`. (Lúc này `[(A, 1)]` bị xóa vì là tổ tiên).
3. **Node B** nhận được bản sao từ A và ghi đè: Clock trở thành `[(A, 2), (B, 1)]`.
4. Bây giờ, nếu có một luồng khác ghi vào **Node C** mà chưa biết về Node B: Clock của C có thể là `[(A, 2), (C, 1)]`.
5. Khi hệ thống đọc dữ liệu, nó thấy `[(A, 2), (B, 1)]` và `[(A, 2), (C, 1)]`. Vì B không phải tổ tiên của C và ngược lại, đây là một **xung đột cần hòa giải**.

Bạn đã đi qua gần như toàn bộ các thành phần kỹ thuật quan trọng nhất của DynamoDB. Những kiến thức này rất hữu ích cho các bài toán về **System Design**. Bạn có muốn tôi thiết kế một sơ đồ tổng hợp cho thấy dữ liệu đi từ `put()` của User qua `Consistent Hashing`, `Quorum`, rồi đến `Vector Clock` và `Merkle Tree` như thế nào không?