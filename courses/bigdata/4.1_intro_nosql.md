## Why NoSQL
- Sự chuyển dịch sang **NoSQL** xuất phát từ việc các ứng dụng Web hiện đại có những yêu cầu đặc thù mà cơ sở dữ liệu quan hệ truyền thống khó đáp ứng hiệu quả. Ưu thế lớn nhất của NoSQL nằm ở khả năng **mở rộng theo chiều ngang (Horizontal scalability)**, cho phép phân phối dữ liệu trên nhiều máy chủ giá rẻ thay vì nâng cấp các máy chủ đắt tiền, đồng thời hỗ trợ khả năng **phân tán địa lý (Geographically distributed)** và tính **co giãn (Elasticity)** linh hoạt theo lưu lượng truy cập. Về mặt phát triển, NoSQL giúp công việc của lập trình viên trở nên dễ dàng hơn nhờ thiết kế **Schema-less** (không ràng buộc lược đồ cứng nhắc), cho phép lưu trữ dữ liệu bán cấu trúc và dữ liệu hỗn hợp (Heterogeneous data storage) một cách tự nhiên mà không cần các bước chuyển đổi phức tạp. Bên cạnh đó, NoSQL được thiết kế để đảm bảo **tính sẵn sàng cao và khả năng phục hồi sau thảm họa (High Availability/Disaster Recovery)** vượt trội. Điều này khả thi là do các ứng dụng Web không phải lúc nào cũng đòi hỏi các đặc tính khắt khe của RDBMS như tính **giao dịch (Transaction)** phức tạp, tính **nhất quán mạnh (Strong consistency)** tức thời hay các **truy vấn phức tạp (Complex queries)** kết nối nhiều bảng. Thay vào đó, NoSQL chấp nhận đánh đổi để ưu tiên hiệu năng và tốc độ phản hồi cho lượng người dùng khổng lồ trên môi trường internet.

## SQL vs NoSQL 
- **SQL** tập trung tối đa vào việc duy trì các thuộc tính **ACID** (Atomicity, Consistency, Isolation, Durability) để đảm bảo mọi giao dịch đều toàn vẹn và nhất quán tuyệt đối, thì **NoSQL** lại ưu tiên mô hình **Eventual Consistency** (nhất quán sau một khoảng thời gian). Điều này có nghĩa là trong NoSQL, dữ liệu có thể không đồng bộ ngay lập tức trên tất cả các node sau một thao tác ghi, nhưng hệ thống đảm bảo chúng sẽ đạt trạng thái thống nhất sau một độ trễ nhất định. Sự khác biệt này tạo nên một ranh giới rõ rệt về mục tiêu thiết kế: SQL coi **Transaction** (giao dịch) là ưu tiên hàng đầu để phục vụ các bài toán yêu cầu độ chính xác cao như tài chính, trong khi NoSQL chấp nhận đánh đổi sự nhất quán tức thời để đạt được **tính sẵn sàng cao (High Availability)** và **khả năng mở rộng cực lớn (High Scalability)**, đáp ứng nhu cầu xử lý dữ liệu khổng lồ của các ứng dụng web hiện đại. Thêm nữa, SQL cần **định nghĩa schema trước** còn NoSQL thì **schemaless**

## Memcached
- **Memcached** là một hệ thống lưu trữ đệm (caching) mã nguồn mở dưới dạng **key-value** hoạt động hoàn toàn trên **bộ nhớ trong (in-memory)**, được thiết kế để tăng tốc các ứng dụng web động bằng cách giảm thiểu tải trọng cho cơ sở dữ liệu. Hệ thống này tận dụng hiệu quả dung lượng RAM dư thừa trên nhiều máy chủ web phân tán để tạo thành một bộ nhớ đệm khổng lồ với giao diện đơn giản và khả năng triển khai nhanh chóng. Với tốc độ truy cập cực nhanh (điển hình chỉ mất khoảng **30ms** cho mỗi lần đọc), Memcached cung cấp các bộ thư viện API hỗ trợ nhiều ngôn ngữ lập trình khác nhau, giúp các nhà phát triển dễ dàng tích hợp vào quy trình phát triển ứng dụng nhằm tối ưu hóa hiệu năng và khả năng phản hồi của hệ thống.

## Redis
- **Redis** là một hệ thống lưu trữ dữ liệu mã nguồn mở dưới dạng **key-value** hoạt động trên bộ nhớ trong (**in-memory**) với khả năng tùy chọn duy trì dữ liệu lên ổ đĩa (**durability**). Khác với các bộ nhớ đệm thông thường, Redis tập trung vào tốc độ đọc và ghi cực cao bằng cách lưu trữ các cấu trúc dữ liệu phổ biến trực tiếp trên RAM, cho phép lưu trữ và thao tác trực tiếp trên các danh sách (**lists**), tập hợp (**sets**), và bảng băm (**hashes**) bên trong giá trị của một khóa. Bên cạnh hiệu năng vượt trội, Redis cung cấp nhiều tính năng mạnh mẽ hỗ trợ nhà phát triển như cơ chế tự động hết hạn dữ liệu (**expiration**), quản lý giao dịch (**transactions**), mô hình truyền tin **pub/sub**, và khả năng phân mảnh dữ liệu (**partitioning**) để mở rộng hệ thống, biến nó thành một công cụ linh hoạt cho cả mục đích làm bộ nhớ đệm lẫn cơ sở dữ liệu chính trong các ứng dụng thời gian thực.

## Amazon DynamoDB
- **Amazon DynamoDB** là một dịch vụ cơ sở dữ liệu **key-value** có khả năng mở rộng linh hoạt và là một trong những sản phẩm phát triển nhanh nhất trong lịch sử của Amazon Web Services. Hệ thống này tập trung tối ưu hóa **thông lượng (throughput)** trên thiết bị lưu trữ, đồng thời đảm bảo **thời gian đọc và ghi dữ liệu có tính dự báo cao (predictable)** ngay cả khi quy mô dữ liệu tăng lên cực lớn. Điểm mạnh vượt trội của DynamoDB còn nằm ở khả năng **tích hợp sâu với hệ sinh thái AWS**, đặc biệt là với **S3** để sao lưu, phục hồi và **Elastic MapReduce (EMR)** để thực hiện các phân tích dữ liệu lớn, giúp doanh nghiệp xây dựng các ứng dụng có độ trễ thấp ở quy mô toàn cầu.


| Đặc điểm | **Memcached** | **Redis** | **Amazon DynamoDB** |
| --- | --- | --- | --- |
| **Bản chất** | Bộ nhớ đệm thuần túy (Volatile Cache). | Kho dữ liệu cấu trúc trong bộ nhớ (In-memory Data Structure Store). | Cơ sở dữ liệu NoSQL được quản lý hoàn toàn (Managed NoSQL DB). |
| **Nơi lưu dữ liệu** | **100% trên RAM**. | **Chủ yếu trên RAM** (có tùy chọn lưu xuống đĩa cứng để bền vững). | **Trên SSD** (lưu trữ vật lý bền vững, replicate qua nhiều Zone). |
| **Cấu trúc dữ liệu** | Key-Value đơn giản (String/Binary). | Rất đa dạng: String, List, Set, Hash, Sorted Set, Bitmap, HyperLogLog, Stream... | Key-Value, Document (JSON). |
| **Độ trễ (Latency)** | Cực thấp (Sub-millisecond). | Cực thấp (Sub-millisecond). | Thấp (Single-digit millisecond) - chậm hơn RAM một chút. |
| **Độ bền (Durability)** | **Không**. Tắt máy là mất sạch. | **Tùy chọn** (RDB snapshot hoặc AOF log). | **Cao**. Dữ liệu được cam kết lưu trữ vĩnh viễn. |
| **Kiến trúc luồng** | **Multi-threaded** (Đa luồng). | **Single-threaded** (Đơn luồng - Event loop)*. | Distributed System (Serverless - Amazon lo phần này). |
| **Khả năng Scale** | Scale-out dễ dàng nhưng Client phải tự định tuyến (Hashing). | Hỗ trợ Redis Cluster, Sentinel cho HA và Partitioning. | Auto-scaling (Tự động mở rộng theo Read/Write Capacity Unit). |

## Column family store
- Mô hình **Column Family Store** là một hệ thống bản đồ (map) đa chiều, phân tán và bền vững, trong đó dữ liệu được sắp xếp và định danh dựa trên bộ ba **(row, column, timestamp)** (có timestamp để lưu lịch sử thay đổi thay vì ghi đè) để truy xuất nội dung ô dữ liệu (cell contents). Khác với các cơ sở dữ liệu truyền thống, mô hình này sử dụng lược đồ động (dynamic schema) và hướng cột, cho phép lưu trữ dữ liệu dưới dạng các ma trận thưa (sparse matrix) cực kỳ hiệu quả.

Điểm đặc trưng của mô hình này là việc nhóm các cột có liên quan chặt chẽ thành các **Column Families**, và có thể tiếp tục nhóm chúng thành các **SuperColumns**. Cấu trúc này cho phép người dùng truy vấn toàn bộ các cột trong cùng một họ (family) hoặc siêu họ (super family) một cách nhanh chóng, đồng thời việc gom nhóm các dữ liệu tương đồng giúp tối ưu hóa tốc độ đọc và xử lý.

So với mô hình quan hệ (RDBMS), Column Family Store mang lại sự linh hoạt vượt trội khi cho phép **một dòng có thể chứa hàng triệu cột** nhưng vẫn duy trì được cấu trúc bảng mà không làm lãng phí không gian nhờ đặc tính lưu trữ thưa. Đây là một dạng lưu trữ lai giữa dòng và cột (hybrid row/column stores), nơi **số lượng cột có thể mở rộng tự do**; lập trình viên có thể chèn thêm các cột mới vào bất kỳ lúc nào mà không cần thực hiện các thao tác thay đổi cấu trúc bảng phức tạp như lệnh "alter table" trong SQL.

## Apache Cassandra
- **Apache Cassandra** là một hệ thống cơ sở dữ liệu **column family** mã nguồn mở mạnh mẽ, được hỗ trợ thương mại bởi DataStax và nổi tiếng với khả năng xử lý quy mô dữ liệu khổng lồ. Khác với mô hình Master-Slave truyền thống, Cassandra hoạt động dựa trên **mô hình phân phối ngang hàng (Peer-to-peer)**, nơi mọi node trong cụm đều có vai trò bình đẳng, giúp loại bỏ điểm lỗi duy nhất và đảm bảo tính sẵn sàng cực cao.

Điểm ấn tượng nhất của Cassandra chính là khả năng **mở rộng tuyến tính (linear scale out)**, cho phép hệ thống duy trì hiệu suất ổn định ngay cả khi tăng số lượng node để xử lý tới hàng triệu lượt ghi mỗi giây. Được viết bằng ngôn ngữ Java, Cassandra có khả năng tương thích và phối hợp rất tốt với hệ sinh thái dữ liệu lớn như **HDFS** và **MapReduce**, biến nó thành lựa chọn hàng đầu cho các ứng dụng yêu cầu ghi dữ liệu tốc độ cao và khả năng chịu lỗi tuyệt đối trên các cụm máy chủ phân tán.

## Graph data model
- Mô hình **Graph data model** (Cơ sở dữ liệu đồ thị) lưu trữ dữ liệu dưới dạng cấu trúc đồ thị tường minh, bao gồm các đỉnh (nodes) và các cạnh (edges) biểu diễn mối quan hệ. Điểm khác biệt cốt lõi là **mỗi node đều biết rõ các node lân cận của nó**, biến các truy vấn thay vì tìm kiếm trên bảng thành các phép **duyệt đồ thị (graph traversals)** để tìm đường đi và mối liên kết.

Khi đặt trong sự tương quan với các hệ thống lưu trữ khác, Graph Database thể hiện những ưu thế vượt trội về mặt kết nối:

* **So với Cơ sở dữ liệu quan hệ (RDBMS):** RDBMS được tối ưu hóa cho các phép **tổng hợp (aggregation)** dữ liệu trên bảng, trong khi Graph Database tối ưu hóa cho các **kết nối (connections)**. Các bài toán tìm mối quan hệ nhiều tầng (như "bạn của bạn của bạn") trong RDBMS đòi hỏi nhiều phép JOIN phức tạp và chậm chạp, nhưng lại là sở trường của Graph Database.
* **So với Key-Value Stores:** Key-Value được tối ưu hóa cho việc **tra cứu đơn giản (look-ups)** dựa trên khóa. Ngược lại, Graph Database tối ưu hóa cho việc **duyệt qua các dữ liệu có tính kết nối cao**, cho phép đi sâu vào các mạng lưới quan hệ phức tạp mà không tốn nhiều chi phí truy xuất.
* **So với Document Stores:** Document Stores tối ưu hóa cho việc quản lý các **cấu trúc cây (trees)** dữ liệu độc lập (như một bài viết kèm các bình luận). Graph Database lại mạnh mẽ hơn khi cho phép bạn nhìn thấy cả **"khu rừng" lẫn "từng cái cây"**, từ gốc rễ đến các nhánh nhỏ nhất, nhờ khả năng liên kết mọi tài liệu lại với nhau trong một mạng lưới tổng thể.

## Neo4j
- **Neo4j** là hệ thống cơ sở dữ liệu đồ thị hàng đầu được thiết kế để mang lại sự tiện dụng tối đa cho các nhà phát triển Java, cho phép tích hợp trực tiếp dưới dạng một thư viện nhúng (**embedded library**) hoặc tương tác qua **REST API**. Khác với các hệ thống chỉ chạy trên bộ nhớ trong, Neo4j là cơ sở dữ liệu **hoạt động trên đĩa (disk-based)**, đảm bảo tính bền vững và tuân thủ đầy đủ các thuộc tính **ACID**, giúp duy trì sự toàn vẹn dữ liệu tuyệt đối ngay cả trong các cấu trúc quan hệ phức tạp.

Về khả năng mở rộng, Neo4j cung cấp sức chứa khổng lồ lên tới **32 tỷ Node**, **32 tỷ Quan hệ** và **64 tỷ Thuộc tính**, đáp ứng tốt nhu cầu của các hệ thống dữ liệu lớn. Đối với các môi trường doanh nghiệp yêu cầu khắt khe, phiên bản Enterprise Edition còn cung cấp tính năng **Sẵn sàng cao (High Availability)**, đảm bảo hệ thống luôn hoạt động ổn định và có khả năng phục hồi sau sự cố, biến nó thành lựa chọn lý tưởng cho các bài toán về mạng xã hội, hệ thống gợi ý hoặc phát hiện gian lận tài chính.

## Document store
- Mô hình **Document store** (Cơ sở dữ liệu dạng tài liệu) thay thế khái niệm các hàng trong bảng hoặc các cặp khóa-giá trị đơn giản bằng các **tài liệu** (documents) tự chứa thông tin. Dữ liệu thường được lưu trữ dưới định dạng **JSON, BSON hoặc XML**, cho phép mỗi bản ghi có cấu trúc khác nhau mà không cần tuân theo một lược đồ cố định. Mỗi tài liệu được định danh duy nhất bằng một **ID**, giúp truy xuất nhanh chóng, đồng thời hệ thống **cho phép đánh chỉ mục (indexing) trên các thuộc tính** bên trong tài liệu. Điều này có nghĩa là bạn có thể tìm kiếm và lọc dữ liệu dựa trên bất kỳ trường thông tin nào nằm sâu trong cấu trúc JSON, giúp việc truy vấn trở nên linh hoạt và hiệu quả hơn so với các kho lưu trữ khóa-giá trị thuần túy.

## Relational Data Mapping
- Quá trình chuyển đổi dữ liệu giữa các tầng kiến trúc, hay còn gọi là **Relational Data Mapping**, là một trong những thách thức lớn nhất khi phát triển ứng dụng web hiện đại. Trong một kiến trúc cơ bản, dữ liệu phải trải qua chu kỳ bốn bước: từ giao diện người dùng (**HTML**) chuyển thành các đối tượng trong mã nguồn (**T1**), sau đó được ánh xạ vào các bảng trong cơ sở dữ liệu quan hệ (**T2**). Khi cần truy xuất, dữ liệu từ các bảng SQL lại được chuyển ngược thành đối tượng (**T3**) để xử lý, trước khi trả về định dạng HTML cho trình duyệt (**T4**).

Sự phức tạp này còn gia tăng đáng kể khi có sự xuất hiện của **Web Service** ở giữa. Lúc này, ngoài 4 bước cơ bản, hệ thống phải thực hiện thêm các bước chuyển đổi đối tượng sang định dạng trao đổi dữ liệu như **XML** hoặc **JSON** (**T5**) và ngược lại (**T6**). Để quản lý sự cồng kềnh này, các nhà phát triển thường sử dụng các framework như **Java Hibernate** hoặc tiêu chuẩn **JPA** (Java Persistence API). Tuy nhiên, việc duy trì cơ chế ánh xạ đối tượng-quan hệ (ORM) vẫn được coi là một trong những thành phần phức tạp nhất. Lời khuyên chung để tránh sự phức tạp quá mức này là giữ cho kiến trúc hệ thống càng đơn giản càng tốt hoặc cân nhắc các giải pháp thay thế như NoSQL nếu mô hình dữ liệu cho phép.

## Document mapping 
- Khác với sự phức tạp của ánh xạ quan hệ (ORM), **Document mapping** mang lại một quy trình tối giản và trực tiếp hơn nhiều. Trong mô hình này, định dạng của **tài liệu trong cơ sở dữ liệu** và **tài liệu trong ứng dụng** (thường là JSON) là hoàn toàn tương đồng, giúp loại bỏ hoàn toàn nhu cầu về một tầng đối tượng trung gian (**No object middle tier**).

Hệ thống không còn phải thực hiện quá trình "phân mảnh" (**No shredding**) — tức là xé lẻ một đối tượng phức tạp thành nhiều hàng trên nhiều bảng khác nhau, cũng như không cần quá trình "tái lắp ráp" (**No reassembly**) dữ liệu từ nhiều bảng thông qua các lệnh JOIN khi cần truy xuất. Mọi thông tin cần thiết đều nằm gọn trong một tài liệu duy nhất, giúp kiến trúc trở nên **đơn giản (Simple!)**, giảm thiểu đáng kể lỗi lập trình và tăng tốc độ phát triển ứng dụng.

## MongoDB
- **MongoDB** là hệ thống lưu trữ dữ liệu dạng JSON mã nguồn mở được phát triển bởi 10gen (nay là MongoDB Inc.), nổi bật với cộng đồng nhà phát triển đông đảo và hệ sinh thái API phong phú hỗ trợ nhiều ngôn ngữ như Java, Python, JavaScript và đặc biệt là được viết bằng ngôn ngữ **C++** để tối ưu hiệu năng. MongoDB sử dụng mô hình mở rộng **Master-slave** và tích hợp sẵn khả năng **Sharding** tự động, cho phép hệ thống phân tán dữ liệu một cách linh hoạt khi quy mô ứng dụng tăng trưởng.

Kiến trúc của MongoDB tập trung vào hai thành phần cốt lõi để đảm bảo hiệu suất và độ tin cậy:

* **Replica Set (Nhân bản):** Cơ chế này tạo ra các bản sao dữ liệu trên nhiều node khác nhau nhằm đảm bảo **an toàn dữ liệu** và **tính sẵn sàng cao (High Availability)**. Nếu một node gặp sự cố, hệ thống có khả năng phục hồi sau thảm họa (Disaster recovery) và duy trì hoạt động bảo trì mà không làm gián đoạn dịch vụ. Ngoài ra, Replica Set còn giúp **mở rộng khả năng đọc (Read scaling)** bằng cách cho phép các thao tác đọc dữ liệu diễn ra trên các bản sao.
* **Sharding (Phân mảnh):** Đây là giải pháp giúp MongoDB **mở rộng theo chiều ngang (Horizontal scale)** bằng cách chia nhỏ dữ liệu thành các "phần" (partitions) và phân phối chúng trên nhiều máy chủ khác nhau. Cơ chế này giúp hệ thống xử lý được lượng dữ liệu và lưu lượng truy cập khổng lồ vượt quá khả năng của một máy chủ đơn lẻ.

## Apache CouchDB
**Apache CouchDB** là một dự án mã nguồn mở thuộc Apache, được thiết kế như một kho lưu trữ dữ liệu JSON hướng tới sự ổn định và khả năng mở rộng vượt trội. Khác với nhiều hệ thống NoSQL khác, CouchDB được viết bằng ngôn ngữ **ERLANG**, một ngôn ngữ nổi tiếng với khả năng xử lý song song và chịu lỗi cực cao. Hệ thống cung cấp một giao tiếp **RESTful JSON API** thuần túy, cho phép lập trình viên tương tác với cơ sở dữ liệu thông qua các phương thức HTTP tiêu chuẩn, giúp việc tích hợp vào các ứng dụng web trở nên vô cùng tự nhiên.

Về mặt kỹ thuật, CouchDB sở hữu những đặc điểm kiến trúc khác biệt để đảm bảo an toàn dữ liệu:

* **Chỉ mục dựa trên B-Tree và Shadowing:** CouchDB sử dụng cấu trúc B-Tree để đánh chỉ mục dữ liệu. Đặc biệt, cơ chế "shadowing b-tree versioning" đảm bảo dữ liệu cũ không bị ghi đè ngay lập tức, hỗ trợ tính năng đa phiên bản (MVCC).
* **Hỗ trợ đầy đủ ACID:** Dù là một NoSQL document store, CouchDB vẫn cam kết tuân thủ các thuộc tính **ACID** ở cấp độ tài liệu, đảm bảo tính toàn vẹn dữ liệu trong mọi giao dịch.
* **View Model & Data Compaction:** Hệ thống sử dụng mô hình View dựa trên MapReduce để truy vấn và tổng hợp dữ liệu. Do cơ chế ghi nối đuôi (append-only) để bảo vệ dữ liệu, CouchDB cung cấp tính năng **Data compaction** (nén dữ liệu) để loại bỏ các phiên bản cũ và tối ưu hóa không gian lưu trữ đĩa.
* **Bảo mật:** CouchDB tích hợp sẵn các cơ chế xác thực và phân quyền chi tiết, đảm bảo an toàn cho dữ liệu trong môi trường phân tán.